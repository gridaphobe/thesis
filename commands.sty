\usepackage{xcolor}
\definecolor{green}{rgb}{0,1,0}
\definecolor{red}{rgb}{1,0,0}
\definecolor{green}{rgb}{0,0,1}
\definecolor{orange}{rgb}{1,0.5,0}
\definecolor{dvcolor}{rgb}{1,0.5,0.5}
\def\mynote#1{{\sf $\clubsuit$ #1$\clubsuit$}}


\def\RJ#1{\textcolor{red}{\sf RJ:$\clubsuit$ #1$\clubsuit$}}
\def\ES#1{\textcolor{blue}{\sf ES:$\clubsuit$ #1$\clubsuit$}}

\newcommand\etc{\textit{etc.}\xspace}
\newcommand\eg{\textit{e.g.}\xspace}
\newcommand\ie{\textit{i.e.}\xspace}
\newcommand\ala{\textit{a la}\xspace}
\newcommand\etal{\textit{et al.}\xspace}
\newcommand\resp{\textit{resp.}\xspace}

\def\emphbf#1{\textbf{\emph{#1}}}
\def\spmid{\ \mid\ }

\newcommand{\lang}{\ensuremath{\lambda^{H}}\xspace}
\newcommand{\ocaml}{\textsc{OCaml}\xspace}
\newcommand{\sherrloc}{\textsc{SHErrLoc}\xspace}
\newcommand{\haskell}{\textsc{Haskell}\xspace}
\newcommand{\java}{\textsc{Java}\xspace}
\newcommand{\ruby}{\textsc{Ruby}\xspace}
\newcommand{\uwbench}{\textsc{UW}\xspace}

\newcommand{\ucsdbench}{\textsc{UCSD}\xspace}
% \newcommand{\ucsdbench}{\textsc{AUTHORS}\xspace}

\newcommand{\uwsize}{284\xspace}
\newcommand{\ucsdsize}{4,407\xspace}

\newcommand\efun[2]{\ensuremath{\lambda #1. #2}\xspace}
\newcommand\eapp[2]{\ensuremath{#1\ #2}\xspace}
\newcommand\eplus[2]{\ensuremath{#1 + #2}\xspace}
% \newcommand\edapp[2]{\ensuremath{#1 \ \overline{#2}}}
\newcommand\eif[3]{\ensuremath{\mathtt{if}\ #1\ \mathtt{then}\ #2\ \mathtt{else}\ #3}\xspace}
\newcommand\elet[3]{\ensuremath{\mathtt{let}\ #1 = #2\ \mathtt{in}\ #3}\xspace}
\newcommand\enode[3]{\ensuremath{\mathtt{node}\ #1\ #2\ #3}\xspace}
\newcommand\eleaf{\ensuremath{\mathtt{leaf}}\xspace}
\newcommand\ecase[6]{\ensuremath{\mathtt{case}\ #1\ \mathtt{of} \begin{cases} \eleaf \to #2\\ \enode{#3}{#4}{#5} \to #6 \end{cases}}\xspace}
\newcommand\ehole{\ensuremath{\nu}\xspace}
\newcommand\thole{\ensuremath{\alpha}\xspace}
\newcommand\epair[2]{\ensuremath{\langle #1, #2 \rangle}\xspace}
\newcommand\epcase[4]{\ensuremath{\mathtt{case}\ #1\ \mathtt{of}\ \epair{#2}{#3} \to #4}\xspace}

% \newcommand\erec[3]{\ensuremath{\mu #1.\lambda #2. #3}}
% \newcommand\etabs[2]{\ensuremath{\left[\Lambda #1\right] #2}}
% \newcommand\etapp[2]{\ensuremath{#1 \left[ #2 \right]}}
\newcommand\etrue{\ensuremath{\mathtt{true}}\xspace}
\newcommand\efalse{\ensuremath{\mathtt{false}}\xspace}
\newcommand\vhole[1]{\ensuremath{\ehole[#1]}\xspace}
\newcommand\vnode[4]{\ensuremath{\mathtt{node}[#1]\ #2\ #3\ #4}\xspace}
\newcommand\vleaf[1]{\ensuremath{\mathtt{leaf}[#1]}\xspace}

\newcommand\stuck{\ensuremath{\mathtt{stuck}}\xspace}
\newcommand\estuck{\ensuremath{\mathbf{e}}\xspace}

%\newcommand\resolve[2]{\ensuremath{\mathsf{resolve}(#1, #2)}\xspace}
\newcommand\resolve[2]{\subst{#2}{#1}\xspace}

% Types
\newcommand\tbool{\ensuremath{\mathtt{bool}}\xspace}
\newcommand\tint{\ensuremath{\mathtt{int}}\xspace}
\newcommand\tlist[1]{\ensuremath{[#1]}\xspace}
\newcommand\econs[2]{\ensuremath{#1 :: #2}\xspace}
\newcommand\enil{\ensuremath{\mathtt{[]}}\xspace}
\newcommand\elcase[5]{\ensuremath{\mathtt{match}\ #1\ \mathtt{with} \begin{cases} \enil \to #2\\ \econs{#3}{#4} \to #5 \end{cases}}\xspace}
% \newcommand\tref[4]{\ensuremath{\{ \tbind{#1}{#2^{#3}} \mid #4 \}}}
% \newcommand\tttref[4]{\ensuremath{{\{ \ttbind{#1}{#2^{#3}} \mid \mathtt{#4} \}}}}
\newcommand\tfun{\ensuremath{\mathtt{fun}}\xspace}
\newcommand\ttree[1]{\ensuremath{\mathtt{tree}\ #1}\xspace}
\newcommand\tprod[2]{\ensuremath{#1 \times #2}\xspace}
% \newcommand\tfun[3]{\ensuremath{\tbind{#1}{#2} \rightarrow #3}}
% \newcommand\tabs[2]{\ensuremath{\forall #1 . #2}}
\newcommand\hastype[2]{\ensuremath{\typeof{#1} = {#2}}}
\newcommand\unifysym{\ensuremath{\mathsf{unify}}\xspace}
\newcommand\unify[2]{\ensuremath{\unifysym(#1,#2)}\xspace}
\newcommand\tsub[2]{\ensuremath{{#1} \preceq {#2}}}
\newcommand\tnsub[2]{\ensuremath{{#1} \npreceq {#2}}}
\newcommand\tcompat[2]{\ensuremath{#1 \sim #2}}
\newcommand\vcompat[2]{\tcompat{#1}{#2}}
\newcommand\vsub[2]{\tsub{#1}{#2}}
\newcommand\vnsub[2]{\tnsub{#1}{#2}}
\newcommand\tincompat[2]{\ensuremath{#1 \nsim #2}}
\newcommand\vincompat[2]{\tincompat{#1}{#2}}

\newcommand\typeofsym{\ensuremath{\mathsf{typeof}}\xspace}
\newcommand\typeof[1]{\ensuremath{\typeofsym(#1)}\xspace}
\newcommand\ptype[2]{\ensuremath{\rho_{#1}(#2)}\xspace}


% Evaluation
\newcommand\trace{\tau}
\newcommand\pair[2]{\langle #1, #2 \rangle}
\newcommand\triple[3]{\langle #1, #2, #3 \rangle}
\newcommand\quadruple[4]{\langle #1, #2, #3, #4 \rangle}
\newcommand\step[6]{\stepsto{\triple{#1}{#2}{#3}}{\triple{#4}{#5}{#6}}}
%\newcommand\stepi[5]{\stepstoi{#1}{\pair{#2}{#3}}{\pair{#4}{#5}}}
\newcommand\steptr[7]{\stepstoi{#1}{\triple{#2}{#3}{#4}}{\triple{#5}{#6}{#7}}}
\newcommand\steps[6]{\stepstot{\triple{#1}{#2}{#3}}{\triple{#4}{#5}{#6}{}}}
\newcommand\stepg[8]{\stepsto{\quadruple{#1}{#2}{#3}{#4}}
                             {\quadruple{#5}{#6}{#7}{#8}}}
\newcommand\stepsg[8]{\stepstot{\quadruple{#1}{#2}{#3}{#4}}
                               {\quadruple{#5}{#6}{#7}{#8}}}
\newcommand\stepsto[2]{\ensuremath{#1 \hookrightarrow #2}}
\newcommand\stepstot[2]{\ensuremath{#1 \hookrightarrow^{*} #2}}
\newcommand\stepstoi[3]{\ensuremath{#2 \hookrightarrow^{#1} #3}}
\newcommand\forcesym{\ensuremath{\mathsf{narrow}}\xspace}
\newcommand\gensym{\ensuremath{\mathsf{gen}}\xspace}
\newcommand\force[4]{\ensuremath{\forcesym(#1, #2, #3, #4)}}
\newcommand\gen[2]{\ensuremath{\gensym(#1,#2)}}
\newcommand\inctx[1]{\ensuremath{C\left[#1\right]}\xspace}
% \newcommand\invctx[1]{\ensuremath{V\left[#1\right]}\xspace}
% \newcommand\intctx[1]{\ensuremath{T\left[#1\right]}\xspace}


\newcommand\dcolon{\ensuremath{\colon\!\!\colon}}
\newcommand\vsu{\ensuremath{\sigma}}
\newcommand\su{\ensuremath{\vsu}}
\newcommand\tsu{\ensuremath{\theta}}
\newcommand\extendsu[3]{\ensuremath{#1\left[#2 \mapsto #3\right]}}
\newcommand\lookupsu[2]{\subst{#1}{#2}}

\newcommand\tr{\ensuremath{G}}
\newcommand\subtermssym{\ensuremath{\mathsf{subterms}}\xspace}
\newcommand\subterms[1]{\ensuremath{\subtermssym(#1)}}
\newcommand\subterm[2]{\ensuremath{#1 \searrow #2}}
\newcommand\singlestep[2]{\ensuremath{#1 \leadsto #2}}
\newcommand\multistep[2]{\ensuremath{#1 \leadsto^{*} #2}}
\newcommand\emptysu{\ensuremath{\varnothing}}
\newcommand\mksub[2]{\ensuremath{\left[#1 \mapsto #2\right]}}
\newcommand\subst[2]{\ensuremath{#1(#2)}}
\newcommand\sub[2]{\ensuremath{\left[#2/#1\right]}}
\newcommand\rulename[1]{\textsc{#1}\xspace}
\newcommand{\recontext}{\rulename{E-Context}}
\newcommand{\restuck}{\rulename{E-Stuck}}
\newcommand{\replusgood}{\rulename{E-Plus-G}}
\newcommand{\replusbadone}{\rulename{E-Plus-B1}}
\newcommand{\replusbadtwo}{\rulename{E-Plus-B2}}
\newcommand{\reifgoodone}{\rulename{E-If-G1}}
\newcommand{\reifgoodtwo}{\rulename{E-If-G2}}
\newcommand{\reifbad}{\rulename{E-If-B}}
\newcommand{\reappgood}{\rulename{E-App-G}}
\newcommand{\reappbad}{\rulename{E-App-B}}
\newcommand{\relet}{\rulename{E-Let}}
\newcommand{\renodegood}{\rulename{E-Node-G}}
\newcommand{\renodebadone}{\rulename{E-Node-B1}}
\newcommand{\renodebadtwo}{\rulename{E-Node-B2}}
\newcommand{\releafgood}{\rulename{E-Leaf-G}}
\newcommand{\recasegoodone}{\rulename{E-Case-G1}}
\newcommand{\recasegoodtwo}{\rulename{E-Case-G2}}
\newcommand{\recasebad}{\rulename{E-Case-B}}
\newcommand{\repcasegood}{\rulename{E-Case-Pair-G}}
\newcommand{\repcasebad}{\rulename{E-Case-Pair-B}}
\newcommand{\reholegood}{\rulename{E-Hole-G}}


\newcommand{\relDescription}[1]{\ensuremath{\textrm{\textbf{#1}}}}
\newcommand{\judgementHead}[2]{\ensuremath{\relDescription{#1}\hfill\fbox{#2}}}
\newcommand{\defeq}{\doteq}

% \newcommand{\genArgsSym}{\ensuremath{\mathsf{genArgs}}\xspace}
% \newcommand{\genArgs}[1]{\ensuremath{\genArgsSym(#1)}\xspace}
% \newcommand{\addArg}[1]{\ensuremath{\mathsf{addArg}(#1)}\xspace}
\newcommand{\evalSym}{\ensuremath{\mathsf{eval}}\xspace}
\newcommand{\eval}[1]{\ensuremath{\evalSym(#1)}\xspace}
% \newcommand{\genWitnessSym}{\ensuremath{\mathsf{genWitness}}\xspace}
% \newcommand{\genWitness}[2]{\ensuremath{\genWitnessSym(#1, #2)}\xspace}


\newcommand\stepoversym{\ensuremath{\mathsf{StepOver}}\xspace}
\newcommand\stepforwardsym{\ensuremath{\mathsf{StepF}}\xspace}
\newcommand\jumpforwardsym{\ensuremath{\mathsf{JumpF}}\xspace}
\newcommand\stepbackwardsym{\ensuremath{\mathsf{StepB}}\xspace}
\newcommand\jumpbackwardsym{\ensuremath{\mathsf{JumpB}}\xspace}
\newcommand\stepintosym{\ensuremath{\mathsf{StepInto}}\xspace}
\newcommand\rootsym{\ensuremath{\mathsf{Root}}\xspace}
\newcommand\pathsym{\ensuremath{\mathsf{Path}}\xspace}

\newcommand\stepforward[2]{\ensuremath{\stepforwardsym(#1, #2)}}
\newcommand\stepbackward[2]{\ensuremath{\stepbackwardsym(#1, #2)}}
\newcommand\jumpforward[2]{\ensuremath{\jumpforwardsym(#1, #2)}}
\newcommand\jumpbackward[2]{\ensuremath{\jumpbackwardsym(#1, #2)}}
\newcommand\stepinto[2]{\ensuremath{\stepintosym(#1, #2)}}
\newcommand\stepover[2]{\ensuremath{\stepoversym(#1, #2)}}

\newcommand\vroot[2]{\ensuremath{\rootsym(#1, #2)}}
\newcommand\vpath[2]{\ensuremath{\pathsym(#1, #2)}}
\newcommand\vstate{\ensuremath{V}}


\newcommand\nanomaly{\textsc{NanoMaLy}\xspace}

\newcommand\putBefore{putBefore}
\newcommand\putAfter{putAfter}
\newcommand\putRoot{putRoot}
\newcommand\getRoot{getRoot}
\newcommand\getPath{path}
\newcommand\getSubterms{getSubterms}
\newcommand\applyCtx{applyCtx}
\newcommand\expr{Expr}
\newcommand\ctx{Ctx}
\newcommand\cmd{Cmd}
\newcommand\findExpr{findExpr}
\newcommand\updState{updState}

\newcommand\stepforwardc{StepForward}
\newcommand\stepbackwardc{StepBack}
\newcommand\jumpforwardc{JumpForward}
\newcommand\jumpbackwardc{JumpBack}
\newcommand\stepintoc{StepInto}
\newcommand\stepoverc{StepOver}


\newcommand\mc[1]{\ensuremath{\mathsf{#1}}}
\newcommand\genWitnessN{\mc{GenWitness}}
\newcommand\genArgsN{\mc{Saturate}}
\newcommand\evalN{\mc{eval}}
\newcommand\takeN{\mc{take}}
\newcommand\loopN{\mc{loop}}

\newcommand{\genWitness}[2]{\ensuremath{\genWitnessN(#1,\ #2)}\xspace}
\newcommand{\genArgs}[1]{\genArgsN(#1)\xspace}
\newcommand{\takefn}[2]{\takeN(#1,\ #2)\xspace}
\newcommand{\evalfn}[1]{\evalN(#1)\xspace}
\newcommand{\loopfn}[1]{\loopN(#1)\xspace}


%%%%% TARGET %%%%%%%%%%%%%
\def\mysection#1{\section{#1}}
\def\mysubsection#1{\subsection{#1}}
\def\mysubsubsection#1{\subsubsection{#1}}

\def\mypara#1{\paragraph{#1}}

%\newcommand\mypara[1]{\smallskip\noindent\emph{\textbf{#1}\xspace}}
\newcommand\tool[1]{\textsc{#1}\xspace}
%\newcommand\toolname{\tool{Target}}

\newcommand\othertool[1]{\tool{#1}\xspace}
\newcommand\quickcheck{\othertool{QuickCheck}}
\newcommand\smallcheck{\othertool{SmallCheck}}
\newcommand\lazysmallcheck{\othertool{Lazy SmallCheck}}
\newcommand\liquidhaskell{\othertool{LiquidHaskell}}
\newcommand\GhcGenerics{\othertool{GHC.Generics}}
\newcommand\smtlogic{QF-EUFLIA\xspace}


\newcommand{\ltup}[2]{\mathrm{({#1},{#2})}}
\newcommand{\lcons}[2]{\mathrm{{#1}:{#2}}}
\newcommand{\lnil}{\mathrm{[]}}
\newcommand{\xor}{\oplus}
%\newcommand{\defeq}{\ \doteq\ }

% \newcommand\val[1]{\sigma(x)}
% \newcommand\cvar[1]{\mathit{{#1}}}
% \newcommand\clen[1]{\cvar{len}\ {#1}}
% \newcommand\cstr[1]{\mathsf{{#1}}}
% \newcommand\ttrue{\cvar{true}}
% \newcommand\tfalse{\cvar{false}}

% \newcommand\meta[1]{[\![#1]\!]}
% \newcommand\reft[3]{\{{#1}:{#2}\ |\ {#3}\}}

% \newcommand\V{\lstinline$v$\xspace}
% \newcommand\X{\lstinline$x$\xspace}
% \newcommand\Y{\lstinline$y$\xspace}
% \newcommand\D{\lstinline$d$\xspace}
% \newcommand\T{\lstinline$t$\xspace}


% \newcommand\Gen{\lstinline$gen$\xspace}
% \newcommand\Stitch{\lstinline$stitch$\xspace}
% \newcommand\ToExpr{\lstinline$toExpr$\xspace}
% \newcommand\Bool{\lstinline$Bool$\xspace}
% \newcommand\Bools{\lstinline$Bool$s\xspace}
% \newcommand\List{\lstinline$List$\xspace}
% \newcommand\Lists{\lstinline$List$s\xspace}
% \newcommand\Nil{\lstinline$Nil$\xspace}
% \newcommand\Cons{\lstinline$Cons$\xspace}
% \newcommand\Choose{\lstinline$choose$\xspace}
% \newcommand\Make{\lstinline$make$\xspace}
% \newcommand\Reverse{\lstinline$reverse$\xspace}
% \newcommand\Insert{\lstinline$insert$\xspace}
% \newcommand\Len{\lstinline$len$\xspace}
% \newcommand\Tail{\lstinline$tail$\xspace}
% \newcommand\Constrain{\lstinline$Constrain$\xspace}
% \newcommand\GConstrain{\lstinline$GConstrain$\xspace}
% \newcommand\Generic{\lstinline$Generic$\xspace}

% \newcommand\PropInsert{\lstinline$prop_insert$\xspace}
% \newcommand\SortedList{\lstinline$SortedList$\xspace}
% \newcommand\Int{\lstinline$Int$\xspace}
% \newcommand\Nat{\lstinline$Nat$\xspace}
% \newcommand\Char{\lstinline$Char$\xspace}
% \newcommand\StackSet{\lstinline$StackSet$\xspace}

% \newcommand\True{\lstinline$true$\xspace}
% \newcommand\SAT{\lstinline$SAT$\xspace}
% \newcommand\UNSAT{\lstinline$UNSAT$\xspace}

% \newcommand\ie{\emph{i.e.}\xspace}
% \newcommand\eg{\emph{e.g.}\xspace}

\newcommand\DONE{\lstinline$D1$\xspace}
\newcommand\CONE{\lstinline$C1$\xspace}
\newcommand\SUM{\lstinline$:+:$\xspace}
\newcommand\PROD{\lstinline$:*:$\xspace}
\newcommand\RECZERO{\lstinline$Rec0$\xspace}

\newcommand\XXX{\ES{XXX}\xspace}

\newcommand\IsNil{\textsc{Is-[]}\xspace}
\newcommand\IsCaseListP{\textsc{Is-Match-List-P}\xspace}
% \newcommand\CountVarP{Count-Var-P\xspace}
\newcommand\ExprSize{\textsc{Expr-Size}\xspace}
\newcommand\HasTypeIntCOne{\textsc{Type-Int-C1}\xspace}
\newcommand\HasTypeList{\textsc{Type-List}\xspace}
\newcommand\InSlice{\textsc{In-Slice}\xspace}

\newcommand\SPRING{\textsc{SP14}\xspace}
\newcommand\FALL{\textsc{FA15}\xspace}

\newcommand\HiddenFhTopOne{73}
\newcommand\HiddenFhTopTwo{86}
\newcommand\HiddenFhTopThree{91}
\newcommand\ToolnameWinOcaml{28\xspace}
\newcommand\ToolnameWinSherrloc{17\xspace}
\newcommand\OcamlTopOne{45}
\newcommand\MycroftTopOne{40}
\newcommand\SherrlocTopOne{56}
\newcommand\SherrlocTopThree{85}
\newcommand\LinearTopOne{60}
\newcommand\LinearTopThree{87}
\newcommand\LinearWinSherrloc{4\xspace}
\newcommand\SlicingWinOcaml{10\xspace}
\newcommand\BaselineTopOne{30}
\newcommand\BaselineTopTwo{47}
\newcommand\BaselineTopThree{59}


\newcommand\labelsym{\mathsf{label}}
\newcommand\featuresym{\mathsf{features}}
\newcommand\extractsym{\mathsf{extract}}
\newcommand\trainsym{\mathsf{train}}
\newcommand\evalsym{\mathsf{eval}}
\newcommand\blamesym{\mathsf{blame}}
\newcommand\Model{\mathsf{Model}}
\newcommand\V{\mathcal{V}}
\newcommand\R{\mathcal{R}}
%\newcommand\Runit{\R_0^1}
\newcommand\Runit{\mathcal{C}}
\newcommand\B{\mathcal{B}}
\newcommand\List[1]{[#1]}


\makeatletter
\newcommand\resetstackedplots{
\makeatletter
\pgfplots@stacked@isfirstplottrue
\makeatother
}
\makeatother

%\newcommand{\lang}{\ensuremath{\lambda^{ML}}\xspace}
\newcommand\mycroft{\textsc{Mycroft}\xspace}
\newcommand\baseline{\textsc{Baseline}\xspace}
\newcommand\random{\textsc{Random}\xspace}
\newcommand\linear{\textsc{Logistic}\xspace}
\newcommand\dectree{\textsc{Tree}\xspace}
\newcommand\forest{\textsc{Forest}\xspace}
\newcommand\hiddenT{\textsc{MLP-10}\xspace}
\newcommand\hiddenTF{\textsc{MLP-25}\xspace}
\newcommand\hiddenF{\textsc{MLP-50}\xspace}
\newcommand\hiddenH{\textsc{MLP-100}\xspace}
\newcommand\hiddenTHF{\textsc{MLP-250}\xspace}
\newcommand\hiddenFH{\textsc{MLP-500}\xspace}
