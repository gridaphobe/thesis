\section{Instantiating the \toolname Framework}\label{sec:list}

Next, we describe a concrete instantiation of \toolname for lists.
%
We start with a constraint generation API~(\S~\ref{sec:constraint}). 
%
Then we use the API to implement the key operations 
\hbox{@query@~(\S~\ref{sec:query}),} 
\hbox{@decode@~(\S~\ref{sec:decode}),} 
\hbox{@check@~(\S~\ref{sec:check}),} and
\hbox{@refuteSMT@~(\S~\ref{sec:refute}),} 
thereby enabling \toolname to automatically test functions over lists.
We omit the definition of @toReft@ as it follows directly from the
definition of @check@.
%
Finally, we show how the list instance can be generalized to algebraic 
datatypes and higher-order functions~(\S~\ref{sec:generic}).

\subsection{SMT Solver Interface}\label{sec:constraint}

Figure~\ref{fig:smt} describes the interface to the SMT 
solvers that \toolname uses for constraint generation and 
model decoding. The interface has functions to 
%
(a)~generate logical variables of type @Var@, 
%
(b)~constrain their values using @Refinement@ predicates, and
%
(c)~determine the values assigned to the variables in satisfying models.

\begin{figure}[ht!]
\begin{mdframed}
\begin{CenteredBox}
\begin{code} 
fresh     :: SMT Var
guard     :: Var -> SMT a      -> SMT a 
constrain :: Var -> Refinement -> SMT ()

apply     :: Ctor -> [Var] -> SMT Var 
unapply   :: Var  -> SMT (Ctor, [Var])

oneOf     :: Var -> [(Var, Var)] -> SMT ()
whichOf   :: Var -> SMT Var

eval      :: Refinement -> SMT Bool
\end{code}
\end{CenteredBox}
\end{mdframed}
\caption{SMT Solver API}\label{fig:smt}
\end{figure}

\begin{itemize}

\item{@fresh@} allocates a new logical variable.

\item{@guard b act@} ensures that all the constraints 
generated by @act@ are \emph{guarded by} the choice 
variable @b@. That is, if @act@ generates the constraint 
$p$ then @guard b act@ generates the (implication) 
constraint ${b \Rightarrow p}$.

\item{@constrain x r@} generates a constraint that @x@ 
satisfies the refinement predicate @r@.

\item{@apply c xs@} generates a new @Var@ for the folded up value 
obtained by applying the constructor @c@ to the fields @xs@,
while also generating constraints from the measures. For example, 
{|apply $\meta{:}$ [$\meta{x_1}$, $\meta{xs_1}$]|} returns |$\meta{\lcons{\cvar{x}_1}{\cvar{xs}_1}}$|
%%%% \ES{$\lcons{\cvar{x}_1}{\cvar{xs}_1}$ doesn't look like a Var.. 
%%%% I guess this works since we've said that Var = Refinement, and 
%%%% it \emph{should} end up generating the constraints from the 
%%%% overview, but still.. I think we could easily confuse people 
%%%% here because of preconceived notions of what a Var is.}
and generates the constraint
${\clen{(\lcons{\cvar{x}_1}{\cvar{xs}_1})} = 1 + \clen{\cvar{xs}_1}}$.

\item{@unapply x@} returns the @Ctor@ and @Var@s from which the input 
@x@ was constructed. 

\item{@oneOf x cxs@} generates a constraint that @x@ equals exactly
one of the elements of @cxs@. For example, 
{|oneOf $\meta{xs_0}$ [($\meta{c_{00}}$,$\meta{[]}$),($\meta{c_{01}}$,$\meta{x_1 : xs_1}$)]|} 
yields:
$$(\cvar{c}_{00} \Rightarrow \cvar{xs}_0 = \lnil) \wedge 
  (\cvar{c}_{01} \Rightarrow \cvar{xs}_0 = \lcons{\cvar{x}_1}{\cvar{xs}_1}) \wedge 
  (\cvar{c}_{00} \oplus \cvar{c}_{01})$$

\item{@whichOf x@} returns the particular alternative that was 
assigned to @x@ in the current model returned by the 
SMT solver. Continuing the previous example, if the model sets 
|$\meta{c_{00}}$| (resp. |$\meta{c_{01}}$|) to $\ttrue$, |whichOf $\meta{xs_0}$| returns 
|$\meta{[]}$| (resp \hbox{|$\meta{x_1 : xs_1}$|).}

\item{@eval r@} checks the validity of a refinement with no free variables. For
  example, |eval $\meta{len\ (1 : []) > 0}$| would return @True@.

\end{itemize}

\subsection{Query}\label{sec:query}

Figure~\ref{fig:query} shows the procedure for constructing a 
@query@ from a refined list type, \eg the one required as an input 
to the @best@ or @insert@ functions from \S~\ref{sec:overview}.

\begin{figure}[t!]
\begin{mdframed}
\begin{CenteredBox}
\begin{mcode}
query p d t = do
  let cs = ctors d
  bs <- forM cs (\_ -> fresh)
  xs <- zipWithM (queryCtor (d-1) t) bs cs
  x  <- fresh 
  oneOf x     (zip bs xs)
  constrain x (refinement t)
  return x

queryCtor d t b c = guard b (do
  let fts = unfold c t
  fs'    <- scanM (queryField d) [] fts
  x      <- apply c fs'
  return x)

queryField d su (f, t) = do
  f' <- query (proxy t) d (t `subst` su)
  return ((f, f') : su, f')                    
ctors d
  | d > 0     = [ $\meta{:}$, $\meta{[]}$ ]
  | otherwise = [ $\meta{[]}$ ]
\end{mcode}
\end{CenteredBox}
\end{mdframed}
\caption{Generating a Query}\label{fig:query}
\end{figure}
% queryField :: Int -> Subst -> (Var, RefType) -> Gen (Subst, Var) 
% queryCtor :: Int -> RefType -> Choice -> Ctor -> Gen Var





\mypara{Lists}
@query@ returns a @Var@ that represent \emph{all} lists up to 
depth @d@ that satisfy the logical constraints associated with 
the refined list type @t@.
%
To this end, it invokes @ctors@ to obtain all of the suitable
constructors for depth @d@. For lists, when
the depth is @0@ we should only use the |$\meta{[]}$| constructor,
otherwise we can use either |$\meta{:}$| or |$\meta{[]}$|. 
This ensures that @query@ terminates after encoding all possible
lists up to a given depth \hbox{@d@.}
%
Next, it uses @fresh@ to generate a distinct \emph{choice} 
variable for each constructor, and calls \hbox{@queryCtor@ to}
generate constraints and a corresponding symbolic @Var@ 
for each constructor. 
%
The choice variable for each constructor is supplied to 
@queryCtor@ to ensure that the constraints are \emph{guarded}, 
\ie only required to hold \emph{if} the corresponding choice 
variable is selected in the model and not otherwise.
%
Finally, a fresh @x@ represents the value at depth @d@ and 
is constrained to be @oneOf@ the alternatives represented 
by the constructors, and to satisfy the top-level refinement of @t@.
%
% Note that the refinements of the components of @t@ will have already 
% been used to constrain the individual alternatives @xs@.


\mypara{Constructors}
@queryCtor@ takes as input the refined list type @t@, 
a depth @d@, a particular constructor @c@ for the list 
type, and generates a query describing the \emph{unfolding}
of @t@ at the constructor @c@, guarded by the choice 
variable @b@ that determines whether this alternative 
is indeed part of the value.
%
These constraints are the conjunction of
those describing the values of the individual fields 
which can be combined via @c@ to obtain a @t@ value.
%
To do so, @queryCtor@ first @unfold@s the type @t@ at 
@c@, obtaining a list of constituent fields and their
respective refinement types @fts@. Next, it uses 
%
\begin{code}
  scanM :: Monad m => (a -> b -> m (a, c)) -> a -> [b] -> m [c]
\end{code}
%
to traverse the fields from left to right, building up 
representations of values for the fields from their 
unfolded refinement types.
%
Finally, we invoke @apply@ on @c@ and the fields @fs'@ to 
return a symbolic representation of the constructed value 
that is constrained to satisfy the measure properties of @c@.

\mypara{Fields}
@queryField@ generates the actual constraints for a
single field @f@ with refinement type @t@, by invoking
@query@ on @t@.  
%
The @proxy@ enables us to resolve the appropriate 
type-class instance for generating the query for 
the field's value.
%
Each field is described by a new symbolic name @f'@ which is 
@subst@ituted for the formal name of the field @f@ in the
refinements of subsequent fields, thereby tracking dependencies
between the fields.
%
For example, these substitutions ensure the values in 
the tail are greater than the head as needed by 
@OrdList@ from \S~\ref{sec:overview}.

\subsection{Decode}\label{sec:decode}
%
\begin{figure}[t!]
\begin{mdframed}
\begin{minipage}{0.45\textwidth}
\begin{CenteredBox}
\begin{code}
decode x = do 
  x'      <- whichOf x
  (c,fs') <- unapply x'
  decodeCtor c fs'
\end{code}
\end{CenteredBox}
\end{minipage}
%
\begin{minipage}{0.55\textwidth}
\begin{CenteredBox}
\begin{mcode}
decodeCtor $\meta{[]}$ []    = return []
decodeCtor $\meta{:}$ [x,xs] = do
  v  <- decode x
  vs <- decode xs
  return (v:vs)
\end{mcode}
\end{CenteredBox}
\end{minipage}
\end{mdframed}
\caption{Decoding Models into Haskell Values}\label{fig:decode}
\end{figure}
%
Once we have generated the constraints we query the SMT solver 
for a model, and if one is found we must \emph{decode} it into
a concrete Haskell value with which to test the given function.
Figure~\ref{fig:decode} shows how to decode an SMT model for lists. 

\mypara{Lists} @decode@ takes as input the top-level symbolic
representation @x@ and queries the model to determine which
alternative was assigned by the solver to @x@, \ie a nil or a cons.
Once the alternative is determined, we use @unapply@ to destruct 
it into its constructor @c@ and fields @fs'@, which are recursively
decoded by @decodeCtor@.

\mypara{Constructors} @decodeCtor@ takes the constructor @c@ and
a list of symbolic representations for fields, and decodes each 
field into a value and applies the constructor to obtain the 
Haskell value.
%
For example, in the case of the |$\meta{[]}$| constructor, there are no
fields, so we return the empty list. In the case of the |$\meta{:}$| 
constructor, we decode the head and the tail, and cons them to 
return the decoded value. 
%
@decodeCtor@ has the type
%
\begin{code}  
  Targetable a => Ctor -> [Var] -> SMT [a]
\end{code}
%
\ie if @a@ is a decodable type, then @decodeCtor@ suffices to decode lists of @a@.
%
Primitives like integers that are directly encoded 
in the refinement logic are the base case -- \ie the 
value in the model is directly translated into the 
corresponding Haskell value.


\subsection{Check}\label{sec:encode}\label{sec:check}
%
\begin{figure}[t!]
\begin{mdframed}
\begin{CenteredBox}
\begin{mcode}
check v t = do
  let (c,vs) = splitCtor v
  let fts    = unfold c t
  (bs, vs') <- fmap unzip (scanM checkField [] (zip vs fts))
  v'        <- apply c vs'
  let t'     = t `subst` [(binder t, v')]
  b'        <- eval (refinement t')
  return (and (b:bs), v')
  
checkField su (v, (f, t)) = do
  (b, v') <- check v (t `subst` su)
  return ((f, v') : su, (b, v'))

splitCtor []     = ($\meta{[]}$, [])
splitCtor (x:xs) = ($\meta{:}$, [x,xs])
\end{mcode}
\end{CenteredBox}
\end{mdframed}
\caption{Checking Outputs}\label{fig:check}
\end{figure}
%
The third step of the query-decode-check loop is to verify
that the output produced by the function under test indeed
satisfies the output refinement type of the function.
%
We accomplish this by \emph{encoding} the output value as a
logical expression, and evaluating the output refinement
applied to the logical representation of the output value.

@check@, shown in Figure~\ref{fig:check}, takes a Haskell
(output) value @v@ and the (output) refinement type @t@, and
recursively verifies each component of the output type. It
converts each component into a logical representation,
@subst@itutes the logical expression for the symbolic value,
and @eval@uates the resulting @Refinement@.

%% We accomplish this by \emph{encoding} the output value as a 
%% set of of logical constraints, and then querying the SMT 
%% solver to check consistency with the output type.

%% @check@, shown in Figure~\ref{fig:check}, takes a Haskell
%% (output) value @v@ and the (output) refinement type @t@,
%% converts @v@ into a logical representation while adding the
%% constraints imposed by @t@, and then checks the consistency
%% of the resulting constraint system.
%% %
%% @encode@ recursively translates the Haskell value into a set
%% of logical constraints, by unfolding the type @t@ to obtain
%% the types of the value's compenents, encoding the components
%% to obtain symbolic fields, invoking @apply@ on the fields to
%% assert the measure properties of the constructor, and
%% finally constraining the resulting symbolic value to satisfy
%% @t@'s refinement.

\subsection{Refuting Models} \label{sec:refute}

Finally, \toolname invokes @refuteSMT@ to \emph{refute} a 
given model in order to force the SMT solver to produce a 
different model that will yield a different test input.
%
A na\"{\i}ve implementation of refutation is as follows.
%
Let $X$ be the set of all variables appearing in the constraints.
%
Suppose that in the current model, each variable $x$ is assigned 
the value $\val{x}$.
%
Then, to refute the model, we add a \emph{refutation constraint} 
$
\vee_{x \in X} x \not = \val{x}
$.
That is, we stipulate that \emph{some} variable be assigned a 
different value.

The na\"{\i}ve  implementation is extremely inefficient.
The SMT solver is free to pick a different value for some 
\emph{irrelevant} variable which was not even used for decoding.
%
As a result, the next model can, after decoding, yield the 
\emph{same} Haskell value, thereby blowing up the number of 
iterations needed to generate all tests of a given size.

\toolname solves this problem by forcing the SMT solver to return
models that yield \emph{different decoded tests} in each iteration.
To this end \toolname restricts the refutation constraint to 
the set of variables that were actually used to @decode@ the 
Haskell value.
%
We track this set by instrumenting the @SMT@ monad to log the 
set of variables and choice-variables that are transitively 
queried via the recursive calls to @decode@.
%
That is, each call to @decode@ logs its argument, and each call 
to @whichOf@ logs the choice variable corresponding to the 
alternative that was returned.
%
Let $R$ be the resulting set of \emph{decode-relevant} variables.
\toolname refutes the model by using a \emph{relevant refutation constraint}
$
\vee_{x \in R} x \not = \val{x}
$
which ensures that the next model decodes to a different value.% than all preceding ones.


\subsection{Generalizing \toolname To Other Types}\label{sec:generic}

The implementation in \S~\ref{sec:list} is for % refined 
List types, but @ctors@, @decodeCtor@, and @splitCtor@ are the only 
functions that are List-specific. 
%
Thus, we can easily generalize the implementation to:
%
\begin{itemize}
%
\item{\emph{primitive datatypes}}, \eg integers, by returning an empty 
    list of constructors,
%    
\item{\emph{algebraic datatypes}}, by implementing @ctors@, @decodeCtor@, and @splitCtor@ for that type.
%
\item{\emph{higher-order functions}}, by lifting instances of @a@ to functions returning @a@.
\end{itemize}

\mypara{Algebraic Datatypes}
% 
Our List implementation has three pieces of type-specific logic:
%
\begin{itemize}
\item{@ctors@}, which returns a list of constructors to unfold;
%
\item{@decodeCtor@}, which decodes a specific @Ctor@; and
%
\item{@splitCtor@}, which splits a Haskell value into a pair of its @Ctor@ and fields. 
\end{itemize}

Thus, to instantiate \toolname on a new data type, all we need is to 
implement these three operations for the type. This implementation
essentially follows the concrete template for Lists.
In fact, we observe that the recipe is entirely mechanical boilerplate,  
and can be fully automated for \emph{all} algebraic data types by using 
a \emph{generics} library.

Any algebraic datatype (ADT) can be represented as a \emph{sum-of-products} 
of component types. A generics library, such as \GhcGenerics~\cite{magalhaes_generic_2010}, 
provides a \emph{univeral} sum-of-products type and functions to automatically 
convert any ADT to and from the universal representation.
Thus, to obtain @Targetable@ instances for \emph{any} ADT it suffices
to define a @Targetable@ instance for the \emph{universal} type.

Once the universal type is @Targetable@ we can automatically get an 
instance for any new user-defined ADT (that is an instance of @Generic@) as follows:
%
(1)~to generate a \emph{query} we simply create a query for 
    \GhcGenerics' universal representation of the refined type,
%
(2)~to \emph{decode} the results from the SMT solver, we 
    decode them into the universal representation and then use 
    \GhcGenerics to map them back into the user-defined type,
%
(3)~to \emph{check} that a given value inhabits a user-defined 
    refinement type, we check that the universal representation 
    of the value inhabits the type's universal counterpart.

The @Targetable@ instance for the universal representation is a 
generalized version of the List instance from \S~\ref{sec:list}, 
that relies on various technical details of \GhcGenerics.
% Thus, we defer it to
% \ifthenelse{\equal{\isTechReport}{true}}{Appendix~\ref{sec:genericapp}}{the Appendix}.

\mypara{Higher Order Functions} 
Our type-directed approach to specification makes it easy to extend
\toolname to higher-order functions. Concretely, it suffices to 
implement a type-class instance:
%
\begin{code}
  instance (Targetable input, Targetable output) 
    => Targetable (input -> output)
\end{code}
%
In essence, this instance uses the @Targetable@ 
instances for @input@ and @output@ to 
create an instance for functions from @input -> output@,
after which Haskell's type class machinery suffices to 
generate concrete function values.

To create such instances, we use the insight from 
\quickcheck, that to generate (constrained) functions,
we need only to generate \emph{output} values for the function. 
%
Following this route, we generate functions by creating 
new lambdas that take in the inputs from the calling context, 
and use their values to create queries for the output, after 
which we can call the SMT solver and decode the results 
to get concrete outputs that are returned by the lambda, 
completing the function definition. 
%
Note that we require @input@ to also be @Targetable@
so that we can encode the Haskell value in the refinement logic,
in order to constrain the output values suitably.
%
We additionally memoize the generated function to preserve the 
illusion of purity. 
%
It is also possible to, in the future, extend our 
implementation to refute functions by asserting 
that the output value for a given input be distinct 
from any previous outputs for that input.
