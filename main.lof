\contentsline {figure}{\numberline {1.1}{\ignorespaces (top-left) An ill-typed \texttt {fac} function, the error location reported by \textsc {OCaml}\xspace is underlined; (bottom-left) Dynamically witnessing the type error in \texttt {fac}, showing only function calls; (right) The same trace, fully expanded.\relax }}{3}{figure.caption.14}
\contentsline {figure}{\numberline {1.2}{\ignorespaces The reduction graph for \texttt {1+2+3}. The two edges produced by the transition from \texttt {1+2+3} to \hbox {\texttt {3+3}} are highlighted.\relax }}{9}{figure.caption.25}
\contentsline {figure}{\numberline {1.3}{\ignorespaces Narrowing values\relax }}{13}{figure.caption.31}
\contentsline {figure}{\numberline {1.4}{\ignorespaces Generating values\relax }}{13}{figure.caption.33}
\contentsline {figure}{\numberline {1.5}{\ignorespaces Evaluation relation for \ensuremath {\lambda ^{H}}\xspace \relax }}{14}{figure.caption.35}
\contentsline {figure}{\numberline {1.6}{\ignorespaces The \emph {dynamic type} of a value.\relax }}{16}{figure.caption.39}
\contentsline {figure}{\numberline {1.7}{\ignorespaces Generating a saturated application.\relax }}{21}{figure.caption.48}
\contentsline {figure}{\numberline {1.8}{\ignorespaces Generating witnesses.\relax }}{22}{figure.caption.50}
\contentsline {figure}{\numberline {1.9}{\ignorespaces A sequence of interactions with the trace of \texttt {fac 1}. The stuck term is red, in each node the redex is highlighted. Thick arrows denote a multi-step transition, thin arrows denote a single-step transition. We start in step 1. In step 2 we jump forward from the witness to the next function call. In step 3 we step into the recursive \texttt {fac 0} call, which spawns a new ``thread'' of execution. In step 4 we take a single step forward from \texttt {fac 0}.\relax }}{42}{figure.caption.55}
\contentsline {figure}{\numberline {1.10}{\ignorespaces Jump-compressed trace of \texttt {fac 1} with subtraction implemented as a function call.\relax }}{43}{figure.caption.58}
\contentsline {figure}{\numberline {1.11}{\ignorespaces Results of our coverage testing and the distribution of test outcomes. Our random search successfully finds witnesses for 79--85\% of the programs in under one second, improving to 87\% in under 10 seconds. In both datasets we detect actual type errors about 82\% of the time, unbound variables or constructors 3--4\% of the time, and diverging loops 2--3\% of the time. For the remaining 11--12\% of the programs we are unable to provide any useful feedback. \relax }}{43}{figure.caption.61}
\contentsline {figure}{\numberline {1.12}{\ignorespaces Complexity of the generated traces. 81\% of the combined traces have a jump complexity of at most 10, with an average complexity of 7 and a median of 5.\relax }}{44}{figure.caption.63}
\contentsline {figure}{\numberline {1.13}{\ignorespaces A classification of students' explanations and fixes for type errors, given either \textsc {OCaml}\xspace 's error or \textsc {NanoMaLy}\xspace 's jump-compressed trace. The students given \textsc {NanoMaLy}\xspace 's jump-compressed trace consistently scored better ($\ge 10\%$) than those given \textsc {OCaml}\xspace 's type error.\relax }}{44}{figure.caption.64}
\contentsline {figure}{\numberline {2.1}{\ignorespaces Refinement Type API\relax }}{58}{figure.caption.85}
\contentsline {figure}{\numberline {2.2}{\ignorespaces The class of types that can be tested by \textsc {NanoMaLy}\xspace \relax }}{59}{figure.caption.86}
\contentsline {figure}{\numberline {2.3}{\ignorespaces Implementing \textsc {NanoMaLy}\xspace via a \emph {query-decode-check} loop\relax }}{61}{figure.caption.87}
\contentsline {figure}{\numberline {2.4}{\ignorespaces SMT Solver API\relax }}{62}{figure.caption.88}
\contentsline {figure}{\numberline {2.5}{\ignorespaces Generating a Query\relax }}{63}{figure.caption.89}
\contentsline {figure}{\numberline {2.6}{\ignorespaces Decoding Models into Haskell Values\relax }}{65}{figure.caption.90}
\contentsline {figure}{\numberline {2.7}{\ignorespaces Checking Outputs\relax }}{66}{figure.caption.91}
\contentsline {figure}{\numberline {2.8}{\ignorespaces Extensions to the refinement type API from Figure\nobreakspace {}\ref {fig:rtype}\relax }}{71}{figure.caption.92}
\contentsline {figure}{\numberline {2.9}{\ignorespaces Generic query generation\relax }}{71}{figure.caption.93}
\contentsline {figure}{\numberline {2.10}{\ignorespaces Generic decoding of Haskell values\relax }}{73}{figure.caption.94}
\contentsline {figure}{\numberline {2.11}{\ignorespaces Generic checking of Haskell values against refinement types.\relax }}{74}{figure.caption.95}
\contentsline {figure}{\numberline {2.12}{\ignorespaces Results of comparing \textsc {NanoMaLy}\xspace with QuickCheck\xspace , SmallCheck\xspace , and Lazy SmallCheck\xspace on a series of functions. \textsc {NanoMaLy}\xspace , SmallCheck\xspace , and Lazy SmallCheck\xspace were both configured to check the first 1000 inputs that satisfied the precondition at increasing depth parameters, with a 60 minute timeout per depth; QuickCheck\xspace was run with the default settings, \textit {i.e.}\xspace it had to produce 100 test cases. \textsc {NanoMaLy}\xspace , SmallCheck\xspace , and Lazy SmallCheck\xspace were configured to use the same notion of depth, in order to ensure they would generate the same number of valid inputs at each depth level. QuickCheck\xspace was unable to successfully complete any run due to the low probability of generating valid inputs at random.\relax }}{76}{figure.caption.96}
\contentsline {figure}{\numberline {2.13}{\ignorespaces Coverage-testing of \texttt {Data.Map.Base}, \texttt {RBTree}, and \texttt {XMonad.StackSet} using \textsc {NanoMaLy}\xspace . Each exported function was tested with increasing depth limits until a single run hit a timeout ranging from one to thirty minutes. Lower is better for ``always-true'' and ``always-false'', higher is better for everything else.\relax }}{83}{figure.caption.97}
