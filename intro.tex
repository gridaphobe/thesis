Static type systems are a marvelous invention.
%
They rule out, at compile-time, an entire class of run-time failures,
\eg dereferencing a |null|-pointer or passing an |int| where a |bool|
was expected.
%
Languages like \ocaml and \haskell make
the value-proposition for types even more
appealing by using constraints to automatically
synthesize the types for all program terms,
without troubling the programmer for any
annotations.
%
Unfortunately, this automation comes at a price.
%
Type annotations signify the programmer's intent, and help to correctly
blame the erroneous sub-term when the code is ill-typed.
%
In the absence of such signifiers, automatic type inference algorithms
are prone to report type errors far from their source
\citep{Wand1986-nw}.
%
While this can seem like a minor annoyance to veteran programmers,
\citet{Joosten1993-yx} have found that novices often focus their
attention on the \emph{location} reported and disregard the
\emph{message}.

In this dissertation we present two new techniques designed to help
\emph{localize} and \emph{explain} type errors.
%
First, in this chapter, we begin with a review of the existing
literature on type errors.
%
Second, we present a new dataset of novice interactions with the \ocaml
type-checker, which will form the backbone of our evaluation.
%
Finally, we present our techniques and evaluate them in the context of
localizing and explaining novice type errors.

\section{A Running Example}
\label{sec:intro:sumList}

\begin{figure}[t]
\small
\begin{minipage}{0.45\linewidth}
\begin{ecode}
let rec sumList xs =
  match xs with
  | []   -> (*@\hlSherrloc{[]}@*)
  | h::t -> h + (*@\hlTree{sumList t}@*)
\end{ecode}
\end{minipage}
\begin{minipage}{0.49\linewidth}
\begin{verbatim}
File "sumList.ml", line 4, characters 16-25:
  This expression has type 'a list
  but an expression was expected of type int

\end{verbatim}
\end{minipage}
\caption{(left) An ill-typed \ocaml program that should sum the elements of a
  list, with highlights indicating two possible blame assignments based on:
  %
  (1) the \hlTree{\ocaml} compiler; and
  %
  (2) the student's \hlSherrloc{fix}.
  %
  % The \underline{underlined} expressions are equally valid
  % locations to blame. The expression blamed by the \ocaml compiler
  % is in \textbf{bold}.
  %
  % FIXME: This bolding is ambiguous, because ``let rec'', ``match'' and
  % ``with'' are also bolded (by \\ecode)! You need to find another way to
  % highlight what ocaml is yelling about.
  %
  (right) The error reported by \ocaml.}
\label{fig:intro:sumList}
\end{figure}

Consider the \ocaml program in \autoref{fig:intro:sumList}, which is
supposed to sum the integers in a list.
%
This program was written by an undergraduate student at UC San Diego,
and works as follows.
%
In functional languages like \ocaml, lists are recursively defined as
either the empty list (written |[]| and pronounced ``nil''), or a single
element |h| followed by the rest of the list |t| (written |h::t| and
pronounced ``h cons t'')\footnote{These variable names are conventional,
  \texttt{h} stands for ``head'' and \texttt{t} for ``tail''.}.
%
Given an input |xs|, the student |match|es it against the
two forms a list can take.
%
In the |[]| case she returns another empty list |[]|, and in the
|h::t| case she adds |h| to the recursive sum of |t|.

The observant reader will notice that this program is incorrect, given
\emph{any} non-empty list of integers, the addition on line 4 will
attempt to add an integer to |[]|, which is an invalid operation.
%
In fact, the program is \emph{ill-typed} and the \ocaml compiler rejects
it with the error message in \autoref{fig:intro:sumList}.
%
Unfortunately, \ocaml's error \emph{blames} the recursive call to
|sumList|, explaining that |sumList| returns a |list|, while the |+|
operator requires an |int|.
%
The real error is on line 3, where the student returns |[]| rather than
|0| as the sum of an empty list.

As we will see throughout the rest of this chapter, this rather simple
program is sufficient to illustrate many of the difficulties of
automatically locating the source of a type error, and explaining it to
the programmer.

\section{A Simple Type System}
\label{sec:intro:simple-type}

\begin{figure}[t]
\centering
\[
\boxed{
\begin{array}{rrcl}
\mathbf{Expressions}
& e & ::=    & x \spmid \efun{x}{e} \spmid \eapp{e}{e} \spmid \elet{x}{e}{e} \\
&   & \spmid & n \spmid \eplus{e}{e}\\
    % & \spmid & b \spmid \eif{e}{e}{e} \\
    % & \spmid & \epair{e}{e} \spmid \epcase{e}{x}{x}{e} \\
&   & \spmid & \enil \spmid \econs{e}{e} \spmid \elcase{e}{e}{x}{x}{e} \\[0.05in]

%\mathbf{Numbers}
& n & ::= &  0, 1, -1, \ldots \\[0.2in]

% b & ::= &  \etrue \spmid \efalse \\[0.05in]
\mathbf{Types}
& t & ::= & \alpha \spmid % \tbool \spmid
            \tint \spmid \tarr{t}{t} \spmid % \tprod{t}{t} \spmid
            \tlist{t} \\[0.05in]
\end{array}
}
\]
\begin{framed}
\judgementHead{Typing}{\jtype{\Gamma}{e}{t}}
\begin{gather*}
\inference[\textsc{Var}]
  {x:t \in \Gamma}
  {\jtype{\Gamma}{x}{t}}
\quad
\inference[\textsc{Lam}]
  {\jtype{\Gamma, x:t_1}{e}{t_2}}
  {\jtype{\Gamma}{\efun{x}{e}}{\tarr{t_1}{t_2}}}
\quad
\inference[\textsc{App}]
  {\jtype{\Gamma}{e_1}{\tarr{t_1}{t_2}}
   \quad
   \jtype{\Gamma}{e_2}{t_1}}
  {\jtype{\Gamma}{\eapp{e_1}{e_2}}{t_2}}
\\[0.1in]
\inference[\textsc{Lit}]
  {}
  {\jtype{\Gamma}{n}{\tint}}
\quad
\inference[\textsc{Plus}]
  {\jtype{\Gamma}{e_1}{\tint} \quad \jtype{\Gamma}{e_2}{\tint}}
  {\jtype{\Gamma}{\eplus{e_1}{e_2}}{\tint}}
\\[0.1in]
\inference[\textsc{Nil}]
  {\alpha \text{ is fresh}}
  {\jtype{\Gamma}{\enil}{\tlist{\alpha}}}
\quad
\inference[\textsc{Cons}]
  {\jtype{\Gamma}{e_1}{t} \quad \jtype{\Gamma}{e_2}{\tlist{t}}}
  {\jtype{\Gamma}{\econs{e_1}{e_2}}{\tlist{t}}}
\\[0.1in]
\inference[\textsc{Match}]
  {\jtype{\Gamma}{e_1}{t_1}
    \quad
   \jtype{\Gamma}{e_2}{t_2}
    \quad
   \jtype{\Gamma,\ x_1:t_1,\ x_2:\tlist{t_1}}{e_3}{t_2}
  }
  {\jtype{\Gamma}{\elcase{e_1}{e_2}{x_1}{x_2}{e_3}}{t_2}}
\end{gather*}
\end{framed}
\caption{A simple $\lambda$-calculus with integers and lists.}
\label{fig:intro:simple-lambda}
\end{figure}

To illustrate the difficulty of pinpointing the source of type errors,
let us consider the simple $\lambda$-calculus with integers and lists in
\autoref{fig:intro:simple-lambda}.


The traditional Damas-Milner Algorithm $\mathcal{W}$~\citep{Damas1982-uw}
traverses the program from the bottom up, collecting typing constraints
at each expression, and halting with an error when it detects an
inconsistent constraint.
%
Thus, given our |sumList| program it will infer that the |[]| case
returns a list while the |h::t| case returns an integer, which violates
the \textsc{Match} rule's constraint that both branches must have the
same type $t_2$.
%
$\mathcal{W}$ will then \emph{blame} the expression that induced the
inconsistent constraint, in this case the entire |match| expression,
while the error was in the base case.

In this case Algorithm $\mathcal{W}$'s error report is actually not so
bad, a well-written error message could convey that the error is due to
the two branches having different types, which may be sufficient to
isolate the source in the base case.
%
But in general, this behavior of bubbling typing constraints up from the
leaves of the program can produce very poor errors~\citep{Wand1986-nw}.
%
In particular, when the same variable is used in different contexts in
different branches \ES{TODO...}

\paragraph{Alternate Traversal Strategies}

As a result, several authors have proposed alternate traversal
strategies to improve the error reports.
%
\citet{Lee1998-ys} describe a ``folklore'' algorithm $\mathcal{M}$ that
traverses the program the top down, rather than from the bottom up, and
prove that it always terminates sooner that $\mathcal{W}$ would, \ie
at a smaller expression.
%
It pushes typing constraints inward from the outer expressions, \eg when
checking the |match| expression in |sumList|, it would infer that the
|[]| branch is a list and would then check that the |h::t| branch is
also a list.
%
This is a subtle but crucial change from $\mathcal{W}$, as $\mathcal{M}$
will abort when \ES{TODO, does it blame the + or the recursive call?}

The fact that algorithm $\mathcal{M}$ (and $\mathcal{W}$) propagates
constraints from one branch to others is known as the ``left-to-right''
bias~\citep{McAdam1998-ub}.
%
Instead of propagating the constraints collected in one branch to
others, \citet{McAdam1998-ub} and \citet{Yang1999-yr} suggest a
\emph{symmetric} traversal that checks each branch independently of the
others and then reports an error when merging two inconsistent sets of
constraints from the branches.
%
One might think we would then be right back at the issue we observed
with algorithm $\mathcal{W}$, with an error reported at the |match|
expression, but \citeauthor{McAdam1998-ub} and \citeauthor{Yang1999-yr}
annotate each constraint with its source location, so that they can
report the conflict between the |[]| on line 3 and the |+| \ES{?} on
line 4.

\paragraph{Type Error Slicing}
\citet{Tip2001-qp} and \citet{Haack2003-vc} extend the work of
\citeauthor{McAdam1998-ub} and \citeauthor{Yang1999-yr}, and compute a
full type error \emph{slice}, \ie all of the sub-expressions that are
required for the error to manifest and no more.
%
For example, one type error slice for |sumList| would be the |match|
expression and its two children, the |[]| and the |+| expression.
%
There is at least one other error slice for |sumList|, which includes
the |[]|, the |+|, the recursive |sumList| call, and the |let rec|
binder, which captures the issue that a list can be passed back through
the recursive call to the |+| operator
%
In general there may be many distinct error slices for the same error,
and while computing one slice can be done efficiently \ES{CITE},
computing all slices is exponential.
%



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
